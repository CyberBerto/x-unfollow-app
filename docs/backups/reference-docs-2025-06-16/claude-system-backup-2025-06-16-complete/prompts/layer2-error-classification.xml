<!-- X Unfollow App Layer 2 Error Classification Prompt -->
<prompt version="1.0" layer="2" project="x-unfollow-app">
  <context>
    <project>X Unfollow App - Layer 2 Error Classification Implementation</project>
    <stack>Python Flask, JavaScript, Bootstrap, X API v2</stack>
    <current_state>Layer 1 complete - 71% complexity reduction, stable foundation</current_state>
    <target_file>app.py around line 450</target_file>
    <implementation_goal>Smart wait times based on error types</implementation_goal>
  </context>
  
  <layer_1_foundation>
    <achievements>
      <complexity_reduction>71% reduction (365 → 105 lines in batch worker)</complexity_reduction>
      <timing_stability>Predictable 15-minute intervals, zero race conditions</timing_stability>
      <functionality>23 functions total, all working reliably</functionality>
      <testing>Complete verification, no regressions</testing>
    </achievements>
    
    <preserve_completely>
      <batch_flow>Sequential processing with queue management</batch_flow>
      <error_handling>Basic error capture and logging</error_handling>
      <timing_system>15-minute intervals for rate limit compliance</timing_system>
      <authentication>OAuth 2.0 with secure token storage</authentication>
      <user_interface>Simple CSV upload and batch management</user_interface>
    </preserve_completely>
  </layer_1_foundation>
  
  <layer_2_implementation>
    <target_location>
      <file>app.py</file>
      <function>slow_batch_worker()</function>
      <line_range>around line 450</line_range>
      <integration_point>After unfollow_user() call, before wait calculation</integration_point>
    </target_location>
    
    <error_classification_function>
      <name>classify_unfollow_error</name>
      <parameters>error_message (str), success (bool)</parameters>
      <returns>error_type (str), wait_seconds (int)</returns>
      <logic>
        <free_errors>
          <types>["not following this account", "user not found", "account suspended", "does not exist"]</types>
          <wait_time>5 seconds</wait_time>
          <reasoning>These errors don't consume API rate limit quota</reasoning>
        </free_errors>
        <expensive_errors>
          <types>["rate limit", "network error", "unknown error", "api error"]</types>
          <wait_time>15 minutes (900 seconds)</wait_time>
          <reasoning>Conservative approach for API quota consumption</reasoning>
        </expensive_errors>
        <success_case>
          <wait_time>15 minutes (900 seconds)</wait_time>
          <reasoning>Maintain Layer 1 timing for successful unfollows</reasoning>
        </success_case>
      </logic>
    </error_classification_function>
    
    <integration_approach>
      <step_1>Add classify_unfollow_error() function after existing functions</step_1>
      <step_2>Modify slow_batch_worker() to use classified wait times</step_2>
      <step_3>Maintain all existing logging and error handling</step_3>
      <step_4>Preserve queue management and progress tracking</step_4>
      <step_5>Keep cancellation and status reporting intact</step_5>
    </integration_approach>
  </layer_2_implementation>
  
  <constraints>
    <foundation_preservation>
      <no_modification>Do not modify Layer 1 core logic, only enhance</no_modification>
      <timing_compliance>Maintain 15-minute intervals for rate limit compliance</timing_compliance>
      <error_handling>Preserve all existing error capture and logging</error_handling>
      <queue_system>Keep batch queue management unchanged</queue_system>
    </foundation_preservation>
    
    <implementation_requirements>
      <incremental>Build on existing code, don't replace</incremental>
      <tested>Verify Layer 1 still works after changes</tested>
      <documented>Log all changes in docs/technical/daily-logs/</documented>
      <conservative>Use 15-minute fallback for uncertain error types</conservative>
    </implementation_requirements>
    
    <code_quality>
      <readability>Clear function names and logic flow</readability>
      <maintainability>Easy to modify error types and wait times</maintainability>
      <consistency>Follow existing code patterns and conventions</consistency>
      <logging>Maintain visual logging with emoji indicators</logging>
    </code_quality>
  </constraints>
  
  <success_criteria>
    <functionality>
      <layer_1_intact>All Layer 1 functionality continues working</layer_1_intact>
      <error_classification>Accurate detection of error types (>95%)</error_classification>
      <smart_timing>5-second waits for free errors, 15-minute for expensive</smart_timing>
      <time_savings>30-50% reduction in total batch completion time</time_savings>
    </functionality>
    
    <user_experience>
      <visible_improvement>Users notice faster batch completion</visible_improvement>
      <reliability>No increase in errors or unexpected behavior</reliability>
      <predictability>Wait times are appropriate for error types</predictability>
      <transparency>Clear indication of smart timing in operation display</transparency>
    </user_experience>
    
    <technical_quality>
      <no_regression>Zero impact to existing Layer 1 functionality</no_regression>
      <performance>Improved batch completion times</performance>
      <maintainability>Easy to add new error types or adjust timing</maintainability>
      <testability>Can verify classification accuracy and timing</testability>
    </technical_quality>
  </success_criteria>
  
  <testing_strategy>
    <layer_1_verification>
      <basic_functionality>Test basic batch processing still works</basic_functionality>
      <queue_management>Verify queue system continues operating</queue_management>
      <authentication>Confirm OAuth flow remains intact</authentication>
      <cancellation>Test batch cancellation still works</cancellation>
    </layer_1_verification>
    
    <layer_2_validation>
      <error_classification>Test with known error types</error_classification>
      <timing_verification>Confirm 5-second vs 15-minute waits</timing_verification>
      <mixed_batches>Test batches with both free and expensive errors</mixed_batches>
      <time_measurement>Measure actual batch completion time improvement</time_measurement>
    </layer_2_validation>
    
    <edge_cases>
      <unknown_errors>Verify fallback to 15-minute wait</unknown_errors>
      <empty_messages>Handle missing or null error messages</empty_messages>
      <rate_limits>Ensure rate limit errors get full 15-minute wait</rate_limits>
      <network_issues>Verify network errors are handled conservatively</network_issues>
    </edge_cases>
  </testing_strategy>
  
  <implementation_checklist>
    <before_coding>
      <read_current_code>Review slow_batch_worker() current implementation</read_current_code>
      <understand_integration>Identify exact integration point for classification</understand_integration>
      <plan_changes>Document specific changes before implementing</plan_changes>
      <backup_current>Ensure current working state is preserved</backup_current>
    </before_coding>
    
    <during_coding>
      <incremental_changes>Make small, testable changes</incremental_changes>
      <preserve_patterns>Follow existing code style and patterns</preserve_patterns>
      <maintain_logging>Keep all existing logging and status updates</maintain_logging>
      <test_frequently>Test after each significant change</test_frequently>
    </during_coding>
    
    <after_coding>
      <verify_layer_1>Confirm all Layer 1 functionality works</verify_layer_1>
      <test_classification>Verify error classification accuracy</test_classification>
      <measure_improvement>Quantify actual time savings achieved</measure_improvement>
      <document_changes>Log all modifications in daily technical log</document_changes>
    </after_coding>
  </implementation_checklist>
  
  <expected_outcomes>
    <immediate_benefits>
      <faster_batches>Significant reduction in batch completion time</faster_batches>
      <better_ux>Users see faster processing for common error scenarios</better_ux>
      <maintained_compliance>Rate limit compliance preserved</maintained_compliance>
      <stable_foundation>Layer 1 functionality completely intact</stable_foundation>
    </immediate_benefits>
    
    <technical_achievements>
      <smart_classification>Intelligent error type detection</smart_classification>
      <optimized_timing>Appropriate wait times for different scenarios</optimized_timing>
      <enhanced_system>Layer 2 built solidly on Layer 1 foundation</enhanced_system>
      <measurable_progress>Quantifiable improvement over Layer 1</measurable_progress>
    </technical_achievements>
    
    <foundation_for_layer_3>
      <error_framework>Error classification system ready for retry logic</error_framework>
      <timing_system>Smart timing ready for network resilience enhancement</timing_system>
      <stable_base>Solid foundation for Layer 3 network retry implementation</stable_base>
    </foundation_for_layer_3>
  </expected_outcomes>
  
  <code_example>
    <function_implementation>
def classify_unfollow_error(error_message, success):
    """
    Layer 2: Classify unfollow errors for intelligent wait timing.
    
    Args:
        error_message (str): Error message from unfollow attempt
        success (bool): Whether unfollow was successful
        
    Returns:
        tuple: (error_type, wait_seconds)
    """
    if success:
        return "success", 15 * 60  # Normal 15-min wait
    
    if not error_message:
        return "unknown", 15 * 60  # Conservative wait
    
    error_lower = error_message.lower()
    
    # Free errors - don't consume rate limit quota
    FREE_ERRORS = [
        "not following this account",
        "user not found", 
        "account suspended",
        "does not exist"
    ]
    
    for free_error in FREE_ERRORS:
        if free_error in error_lower:
            return "user_specific", 5  # 5-second wait
    
    # Expensive/unknown errors - be conservative
    return "unknown", 15 * 60  # 15-minute wait
    </function_implementation>
    
    <integration_example>
# In slow_batch_worker(), around line 450:
# Replace fixed wait with classified wait

# Current Layer 1 code (preserve this pattern):
result = x_client.unfollow_user(username)
success = result.get('success', False)
error_message = result.get('error', '')

# Layer 2 enhancement:
error_type, wait_seconds = classify_unfollow_error(error_message, success)

# Enhanced logging with error classification:
if success:
    logging.info(f"✅ Unfollowed @{username} successfully (waiting {wait_seconds}s)")
else:
    logging.info(f"❌ Failed to unfollow @{username}: {error_message} (type: {error_type}, waiting {wait_seconds}s)")

# Use classified wait time instead of fixed 15 minutes:
time.sleep(wait_seconds)
    </integration_example>
  </code_example>
</prompt>